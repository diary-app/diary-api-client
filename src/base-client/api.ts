/* tslint:disable */
/* eslint-disable */
/**
 * A personal diary API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AcceptSharedDiaryRequest
 */
export interface AcceptSharedDiaryRequest {
    /**
     * ID of shared diary which current user accepts
     * @type {string}
     * @memberof AcceptSharedDiaryRequest
     */
    'diaryId': string;
    /**
     * Diary key encrypted with current user\'s master-key
     * @type {string}
     * @memberof AcceptSharedDiaryRequest
     */
    'encryptedDiaryKey': string;
}
/**
 * 
 * @export
 * @interface AuthResult
 */
export interface AuthResult {
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface AvailableSharingTasksListDto
 */
export interface AvailableSharingTasksListDto {
    /**
     * 
     * @type {Array<SharingTaskDto>}
     * @memberof AvailableSharingTasksListDto
     */
    'items': Array<SharingTaskDto>;
}
/**
 * 
 * @export
 * @interface CreateDiaryEntryRequest
 */
export interface CreateDiaryEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDiaryEntryRequest
     */
    'diaryId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiaryEntryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiaryEntryRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDiaryEntryRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateSharingTaskRequest
 */
export interface CreateSharingTaskRequest {
    /**
     * ID of diary entry to share
     * @type {string}
     * @memberof CreateSharingTaskRequest
     */
    'entryId': string;
    /**
     * New encryption key with which entry contents were encrypted. The key is encrypted with current user\'s master-key
     * @type {string}
     * @memberof CreateSharingTaskRequest
     */
    'myEncryptedKey': string;
    /**
     * New encryption key with which entry contents were encrypted. The key is encrypted with receiver user\'s public key
     * @type {string}
     * @memberof CreateSharingTaskRequest
     */
    'receiverEncryptedKey': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSharingTaskRequest
     */
    'receiverUserId': string;
    /**
     * Value of the entry encrypted with new encryption key
     * @type {string}
     * @memberof CreateSharingTaskRequest
     */
    'value': string;
    /**
     * Block of the entry being shared, encrypted with new encryption key
     * @type {Array<DiaryEntryBlockDto>}
     * @memberof CreateSharingTaskRequest
     */
    'blocks': Array<DiaryEntryBlockDto>;
}
/**
 * 
 * @export
 * @interface CreateSharingTaskResponseDto
 */
export interface CreateSharingTaskResponseDto {
    /**
     * ID of new diary which now contains the shared entry
     * @type {string}
     * @memberof CreateSharingTaskResponseDto
     */
    'diaryId': string;
}
/**
 * 
 * @export
 * @interface DiariesListDto
 */
export interface DiariesListDto {
    /**
     * 
     * @type {Array<DiaryDto>}
     * @memberof DiariesListDto
     */
    'items': Array<DiaryDto>;
}
/**
 * 
 * @export
 * @interface DiaryDto
 */
export interface DiaryDto {
    /**
     * 
     * @type {string}
     * @memberof DiaryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DiaryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DiaryDto
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof DiaryDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface DiaryEntryBlockDto
 */
export interface DiaryEntryBlockDto {
    /**
     * 
     * @type {string}
     * @memberof DiaryEntryBlockDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DiaryEntryBlockDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ErrorDto
 */
export interface ErrorDto {
    /**
     * 
     * @type {string}
     * @memberof ErrorDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface FullDiaryEntryDto
 */
export interface FullDiaryEntryDto {
    /**
     * 
     * @type {string}
     * @memberof FullDiaryEntryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullDiaryEntryDto
     */
    'diaryId': string;
    /**
     * 
     * @type {string}
     * @memberof FullDiaryEntryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FullDiaryEntryDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof FullDiaryEntryDto
     */
    'value': string;
    /**
     * 
     * @type {Array<DiaryEntryBlockDto>}
     * @memberof FullDiaryEntryDto
     */
    'blocks': Array<DiaryEntryBlockDto>;
}
/**
 * 
 * @export
 * @interface FullDiaryEntryDtoAllOf
 */
export interface FullDiaryEntryDtoAllOf {
    /**
     * 
     * @type {string}
     * @memberof FullDiaryEntryDtoAllOf
     */
    'value'?: string;
    /**
     * 
     * @type {Array<DiaryEntryBlockDto>}
     * @memberof FullDiaryEntryDtoAllOf
     */
    'blocks'?: Array<DiaryEntryBlockDto>;
}
/**
 * 
 * @export
 * @interface FullUserDto
 */
export interface FullUserDto {
    /**
     * 
     * @type {string}
     * @memberof FullUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullUserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof FullUserDto
     */
    'publicKeyForSharing': string;
    /**
     * 
     * @type {string}
     * @memberof FullUserDto
     */
    'masterKeySalt': string;
    /**
     * 
     * @type {string}
     * @memberof FullUserDto
     */
    'encryptedPrivateKeyForSharing': string;
}
/**
 * 
 * @export
 * @interface FullUserDtoAllOf
 */
export interface FullUserDtoAllOf {
    /**
     * 
     * @type {string}
     * @memberof FullUserDtoAllOf
     */
    'masterKeySalt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUserDtoAllOf
     */
    'encryptedPrivateKeyForSharing'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'masterKeySalt': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'publicKeyForSharing': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'encryptedPrivateKeyForSharing': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'encryptedDiaryKey': string;
}
/**
 * 
 * @export
 * @interface RegistrationResult
 */
export interface RegistrationResult {
    /**
     * 
     * @type {string}
     * @memberof RegistrationResult
     */
    'token': string;
    /**
     * ID of new diary crated for the registered user
     * @type {string}
     * @memberof RegistrationResult
     */
    'diaryId': string;
}
/**
 * 
 * @export
 * @interface SharingTaskDto
 */
export interface SharingTaskDto {
    /**
     * ID of the diary being shared
     * @type {string}
     * @memberof SharingTaskDto
     */
    'diaryId': string;
    /**
     * ID of the user received access to diary
     * @type {string}
     * @memberof SharingTaskDto
     */
    'receiverUserId': string;
    /**
     * Diary key encrypted with public key of receiving user
     * @type {string}
     * @memberof SharingTaskDto
     */
    'encryptedDiaryKey': string;
    /**
     * Name of the user who owns the shared diary
     * @type {string}
     * @memberof SharingTaskDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SharingTaskDto
     */
    'sharedAt': string;
}
/**
 * 
 * @export
 * @interface ShortDiariesEntriesListDto
 */
export interface ShortDiariesEntriesListDto {
    /**
     * 
     * @type {Array<ShortDiaryEntryDto>}
     * @memberof ShortDiariesEntriesListDto
     */
    'items': Array<ShortDiaryEntryDto>;
}
/**
 * 
 * @export
 * @interface ShortDiaryEntryDto
 */
export interface ShortDiaryEntryDto {
    /**
     * 
     * @type {string}
     * @memberof ShortDiaryEntryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShortDiaryEntryDto
     */
    'diaryId': string;
    /**
     * 
     * @type {string}
     * @memberof ShortDiaryEntryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShortDiaryEntryDto
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface ShortUserDto
 */
export interface ShortUserDto {
    /**
     * 
     * @type {string}
     * @memberof ShortUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShortUserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ShortUserDto
     */
    'publicKeyForSharing': string;
}
/**
 * 
 * @export
 * @interface UpdateDiaryEntryRequest
 */
export interface UpdateDiaryEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateDiaryEntryRequest
     */
    'diaryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDiaryEntryRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDiaryEntryRequest
     */
    'date'?: string;
    /**
     * 
     * @type {Array<DiaryEntryBlockDto>}
     * @memberof UpdateDiaryEntryRequest
     */
    'blocksToUpsert'?: Array<DiaryEntryBlockDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateDiaryEntryRequest
     */
    'blocksToDelete'?: Array<string>;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login as an existing user with provided username and password
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLoginPost: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('v1AuthLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh existing auth token within 5 minutes until its expiration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRefreshTokenPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new user with specified username/password and extra data
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRegisterPost: async (registerRequest: RegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('v1AuthRegisterPost', 'registerRequest', registerRequest)
            const localVarPath = `/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Login as an existing user with provided username and password
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthLoginPost(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthLoginPost(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh existing auth token within 5 minutes until its expiration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthRefreshTokenPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthRefreshTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register new user with specified username/password and extra data
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthRegisterPost(registerRequest: RegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthRegisterPost(registerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Login as an existing user with provided username and password
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLoginPost(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthResult> {
            return localVarFp.v1AuthLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh existing auth token within 5 minutes until its expiration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRefreshTokenPost(options?: any): AxiosPromise<AuthResult> {
            return localVarFp.v1AuthRefreshTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Register new user with specified username/password and extra data
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthRegisterPost(registerRequest: RegisterRequest, options?: any): AxiosPromise<RegistrationResult> {
            return localVarFp.v1AuthRegisterPost(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Login as an existing user with provided username and password
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthLoginPost(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh existing auth token within 5 minutes until its expiration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthRefreshTokenPost(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthRefreshTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new user with specified username/password and extra data
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public v1AuthRegisterPost(registerRequest: RegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).v1AuthRegisterPost(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiariesApi - axios parameter creator
 * @export
 */
export const DiariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get available diaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiariesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/diaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiariesApi - functional programming interface
 * @export
 */
export const DiariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiariesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get available diaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DiariesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiariesListDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DiariesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiariesApi - factory interface
 * @export
 */
export const DiariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiariesApiFp(configuration)
    return {
        /**
         * Get available diaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiariesGet(options?: any): AxiosPromise<DiariesListDto> {
            return localVarFp.v1DiariesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiariesApi - object-oriented interface
 * @export
 * @class DiariesApi
 * @extends {BaseAPI}
 */
export class DiariesApi extends BaseAPI {
    /**
     * Get available diaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiariesApi
     */
    public v1DiariesGet(options?: AxiosRequestConfig) {
        return DiariesApiFp(this.configuration).v1DiariesGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiaryEntriesApi - axios parameter creator
 * @export
 */
export const DiaryEntriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get diary entries
         * @param {string} [diaryId] 
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesGet: async (diaryId?: string, date?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/diary-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (diaryId !== undefined) {
                localVarQueryParameter['diaryId'] = diaryId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update diary entry
         * @param {string} id ID of the entry to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DiaryEntriesIdDelete', 'id', id)
            const localVarPath = `/v1/diary-entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get diary entry
         * @param {string} id ID of entry to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DiaryEntriesIdGet', 'id', id)
            const localVarPath = `/v1/diary-entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update diary entry
         * @param {string} id ID of the entry to update
         * @param {UpdateDiaryEntryRequest} updateDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesIdPatch: async (id: string, updateDiaryEntryRequest: UpdateDiaryEntryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DiaryEntriesIdPatch', 'id', id)
            // verify required parameter 'updateDiaryEntryRequest' is not null or undefined
            assertParamExists('v1DiaryEntriesIdPatch', 'updateDiaryEntryRequest', updateDiaryEntryRequest)
            const localVarPath = `/v1/diary-entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiaryEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create diary entry
         * @param {CreateDiaryEntryRequest} createDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesPost: async (createDiaryEntryRequest: CreateDiaryEntryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDiaryEntryRequest' is not null or undefined
            assertParamExists('v1DiaryEntriesPost', 'createDiaryEntryRequest', createDiaryEntryRequest)
            const localVarPath = `/v1/diary-entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDiaryEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiaryEntriesApi - functional programming interface
 * @export
 */
export const DiaryEntriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiaryEntriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get diary entries
         * @param {string} [diaryId] 
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DiaryEntriesGet(diaryId?: string, date?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortDiariesEntriesListDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DiaryEntriesGet(diaryId, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update diary entry
         * @param {string} id ID of the entry to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DiaryEntriesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DiaryEntriesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get diary entry
         * @param {string} id ID of entry to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DiaryEntriesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullDiaryEntryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DiaryEntriesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update diary entry
         * @param {string} id ID of the entry to update
         * @param {UpdateDiaryEntryRequest} updateDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DiaryEntriesIdPatch(id: string, updateDiaryEntryRequest: UpdateDiaryEntryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortDiaryEntryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DiaryEntriesIdPatch(id, updateDiaryEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create diary entry
         * @param {CreateDiaryEntryRequest} createDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DiaryEntriesPost(createDiaryEntryRequest: CreateDiaryEntryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortDiaryEntryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DiaryEntriesPost(createDiaryEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiaryEntriesApi - factory interface
 * @export
 */
export const DiaryEntriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiaryEntriesApiFp(configuration)
    return {
        /**
         * Get diary entries
         * @param {string} [diaryId] 
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesGet(diaryId?: string, date?: string, options?: any): AxiosPromise<ShortDiariesEntriesListDto> {
            return localVarFp.v1DiaryEntriesGet(diaryId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Update diary entry
         * @param {string} id ID of the entry to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.v1DiaryEntriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get diary entry
         * @param {string} id ID of entry to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesIdGet(id: string, options?: any): AxiosPromise<FullDiaryEntryDto> {
            return localVarFp.v1DiaryEntriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update diary entry
         * @param {string} id ID of the entry to update
         * @param {UpdateDiaryEntryRequest} updateDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesIdPatch(id: string, updateDiaryEntryRequest: UpdateDiaryEntryRequest, options?: any): AxiosPromise<ShortDiaryEntryDto> {
            return localVarFp.v1DiaryEntriesIdPatch(id, updateDiaryEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create diary entry
         * @param {CreateDiaryEntryRequest} createDiaryEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DiaryEntriesPost(createDiaryEntryRequest: CreateDiaryEntryRequest, options?: any): AxiosPromise<ShortDiaryEntryDto> {
            return localVarFp.v1DiaryEntriesPost(createDiaryEntryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiaryEntriesApi - object-oriented interface
 * @export
 * @class DiaryEntriesApi
 * @extends {BaseAPI}
 */
export class DiaryEntriesApi extends BaseAPI {
    /**
     * Get diary entries
     * @param {string} [diaryId] 
     * @param {string} [date] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiaryEntriesApi
     */
    public v1DiaryEntriesGet(diaryId?: string, date?: string, options?: AxiosRequestConfig) {
        return DiaryEntriesApiFp(this.configuration).v1DiaryEntriesGet(diaryId, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update diary entry
     * @param {string} id ID of the entry to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiaryEntriesApi
     */
    public v1DiaryEntriesIdDelete(id: string, options?: AxiosRequestConfig) {
        return DiaryEntriesApiFp(this.configuration).v1DiaryEntriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get diary entry
     * @param {string} id ID of entry to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiaryEntriesApi
     */
    public v1DiaryEntriesIdGet(id: string, options?: AxiosRequestConfig) {
        return DiaryEntriesApiFp(this.configuration).v1DiaryEntriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update diary entry
     * @param {string} id ID of the entry to update
     * @param {UpdateDiaryEntryRequest} updateDiaryEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiaryEntriesApi
     */
    public v1DiaryEntriesIdPatch(id: string, updateDiaryEntryRequest: UpdateDiaryEntryRequest, options?: AxiosRequestConfig) {
        return DiaryEntriesApiFp(this.configuration).v1DiaryEntriesIdPatch(id, updateDiaryEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create diary entry
     * @param {CreateDiaryEntryRequest} createDiaryEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiaryEntriesApi
     */
    public v1DiaryEntriesPost(createDiaryEntryRequest: CreateDiaryEntryRequest, options?: AxiosRequestConfig) {
        return DiaryEntriesApiFp(this.configuration).v1DiaryEntriesPost(createDiaryEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharingTasksApi - axios parameter creator
 * @export
 */
export const SharingTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accept shared diary key
         * @param {AcceptSharedDiaryRequest} acceptSharedDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SharingTasksAcceptPost: async (acceptSharedDiaryRequest: AcceptSharedDiaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptSharedDiaryRequest' is not null or undefined
            assertParamExists('v1SharingTasksAcceptPost', 'acceptSharedDiaryRequest', acceptSharedDiaryRequest)
            const localVarPath = `/v1/sharing-tasks/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptSharedDiaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available sharing tasks where current user is receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SharingTasksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sharing-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create sharing task to share a diary
         * @param {CreateSharingTaskRequest} createSharingTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SharingTasksPost: async (createSharingTaskRequest: CreateSharingTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSharingTaskRequest' is not null or undefined
            assertParamExists('v1SharingTasksPost', 'createSharingTaskRequest', createSharingTaskRequest)
            const localVarPath = `/v1/sharing-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSharingTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharingTasksApi - functional programming interface
 * @export
 */
export const SharingTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharingTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Accept shared diary key
         * @param {AcceptSharedDiaryRequest} acceptSharedDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SharingTasksAcceptPost(acceptSharedDiaryRequest: AcceptSharedDiaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SharingTasksAcceptPost(acceptSharedDiaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get available sharing tasks where current user is receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SharingTasksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableSharingTasksListDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SharingTasksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create sharing task to share a diary
         * @param {CreateSharingTaskRequest} createSharingTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SharingTasksPost(createSharingTaskRequest: CreateSharingTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSharingTaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SharingTasksPost(createSharingTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharingTasksApi - factory interface
 * @export
 */
export const SharingTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharingTasksApiFp(configuration)
    return {
        /**
         * Accept shared diary key
         * @param {AcceptSharedDiaryRequest} acceptSharedDiaryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SharingTasksAcceptPost(acceptSharedDiaryRequest: AcceptSharedDiaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.v1SharingTasksAcceptPost(acceptSharedDiaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available sharing tasks where current user is receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SharingTasksGet(options?: any): AxiosPromise<AvailableSharingTasksListDto> {
            return localVarFp.v1SharingTasksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create sharing task to share a diary
         * @param {CreateSharingTaskRequest} createSharingTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SharingTasksPost(createSharingTaskRequest: CreateSharingTaskRequest, options?: any): AxiosPromise<CreateSharingTaskResponseDto> {
            return localVarFp.v1SharingTasksPost(createSharingTaskRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharingTasksApi - object-oriented interface
 * @export
 * @class SharingTasksApi
 * @extends {BaseAPI}
 */
export class SharingTasksApi extends BaseAPI {
    /**
     * Accept shared diary key
     * @param {AcceptSharedDiaryRequest} acceptSharedDiaryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharingTasksApi
     */
    public v1SharingTasksAcceptPost(acceptSharedDiaryRequest: AcceptSharedDiaryRequest, options?: AxiosRequestConfig) {
        return SharingTasksApiFp(this.configuration).v1SharingTasksAcceptPost(acceptSharedDiaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available sharing tasks where current user is receiver
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharingTasksApi
     */
    public v1SharingTasksGet(options?: AxiosRequestConfig) {
        return SharingTasksApiFp(this.configuration).v1SharingTasksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create sharing task to share a diary
     * @param {CreateSharingTaskRequest} createSharingTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharingTasksApi
     */
    public v1SharingTasksPost(createSharingTaskRequest: CreateSharingTaskRequest, options?: AxiosRequestConfig) {
        return SharingTasksApiFp(this.configuration).v1SharingTasksPost(createSharingTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get public info about user by their ID
         * @param {string} id ID of the user whose info is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1UsersIdGet', 'id', id)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get full info about current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public info about current user
         * @param {string} [name] Name of the user whose info is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersNamenameGet: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users/name={name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get public info about user by their ID
         * @param {string} id ID of the user whose info is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get full info about current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get public info about current user
         * @param {string} [name] Name of the user whose info is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersNamenameGet(name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShortUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersNamenameGet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get public info about user by their ID
         * @param {string} id ID of the user whose info is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersIdGet(id: string, options?: any): AxiosPromise<ShortUserDto> {
            return localVarFp.v1UsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get full info about current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMeGet(options?: any): AxiosPromise<FullUserDto> {
            return localVarFp.v1UsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get public info about current user
         * @param {string} [name] Name of the user whose info is requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersNamenameGet(name?: string, options?: any): AxiosPromise<ShortUserDto> {
            return localVarFp.v1UsersNamenameGet(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get public info about user by their ID
     * @param {string} id ID of the user whose info is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersIdGet(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get full info about current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersMeGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public info about current user
     * @param {string} [name] Name of the user whose info is requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public v1UsersNamenameGet(name?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).v1UsersNamenameGet(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet(options?: any): AxiosPromise<void> {
            return localVarFp.pingGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilsApi
     */
    public pingGet(options?: AxiosRequestConfig) {
        return UtilsApiFp(this.configuration).pingGet(options).then((request) => request(this.axios, this.basePath));
    }
}


